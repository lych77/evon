// Copyright (c) 2020, lych77
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

package main

var localIdents = [...]string{"ev", "em", "s", "h", "wg"}

const templateText = `// Code generated by evon. DO NOT EDIT.

package {{.Package}}

{{- if .Imports}}
	import ({{range .Imports}}{{.Alias}}"{{.Path}}";{{end}})
{{- end}}

{{- range .Events}}
	{{- $ev := index .Dedups "ev"}}
	{{- $s := index .Dedups "s"}}
	{{- $h := index .Dedups "h"}}
	{{- $wg := index .Dedups "wg"}}

	{{- $hdlrTyp := printf "%s%s" .Name $.HandlerSuffix}}
	{{- $evTyp := printf "%s%s" .Name $.EventSuffix}}
	{{- $slotTyp := printf "__evon_%s_slot__" .Name}}
	{{- $emitterTyp := printf "__evon_%s_emitter__" .Name}}

	{{- $compSlot := or .Flags.unsub .Flags.queue}}

	{{- $intf := ne (index .Funcs 0).Name ""}}

	// {{$evTyp}} is the **evon** event dispatcher type for {{$hdlrTyp}} handlers.
	// Flags: {{.FlagsLit}}.
	type {{$evTyp}} struct {
		{{if $intf}}Emit {{$emitterTyp}};{{end -}}
		slots []{{if $compSlot}}{{$slotTyp}}{{else}}{{$hdlrTyp}}{{end}};
		{{- if .Flags.queue}}qsize int;{{end}}
		{{- if .Flags.lock}}lock {{$.SyncAlias}}.RWMutex;{{end}}
		{{- if .Flags.pause}}paused bool;{{end}}
		{{- if .Flags.catch}}catch func(interface{});{{end}}
	}

	{{if $compSlot}}
		type {{$slotTyp}} struct {
			handler {{$hdlrTyp}};
			{{- if .Flags.unsub}}index *int;{{end}}
			{{- if .Flags.queue}}queue chan func();{{end}}
		}
	{{end}}

	{{- if $intf}}
		type {{$emitterTyp}} struct {
			ev *{{$evTyp}}
		}
	{{end}}

	{{- $flags := .Flags}}
	{{- $em := index .Dedups "em"}}
	{{- $recv := printf "(%s *%s)" $ev $evTyp}}
	{{- $evLoc := $ev}}
	{{- if $intf}}
		{{- $recv = printf "(%s %s)" $em $emitterTyp}}
		{{- $evLoc = printf "%s.ev" $em}}
	{{end}}

	
	{{- $hdlrArg := $s}}
	{{- if $compSlot}}{{$hdlrArg = printf "%s.handler" $s}}{{end}}

	{{- range .Funcs}}
		{{$wrapBegin := ""}}
		{{$wrapEnd := ""}}
		{{$hdlrParam := ""}}
		{{if $flags.spawn}}
			{{$wrapBegin = printf "go func(%s %s) {" $h $hdlrTyp}}
			{{$wrapEnd = printf "}(%s)" $hdlrArg}}
			{{$hdlrParam = $h}}
		{{else if $flags.queue}}
			{{$wrapBegin = printf "%s.queue <- func(%s %s) func() { return func() {" $s $h $hdlrTyp}}
			{{$wrapEnd = printf "}}(%s)" $hdlrArg}}
			{{$hdlrParam = $h}}
		{{else if $flags.catch}}
			{{$wrapBegin = "func() {"}}
			{{$wrapEnd = "}()"}}
		{{end}}

		// {{or .Name "Emit"}} emits an event to all subscribed handlers.
		func {{$recv}} {{or .Name "Emit"}}({{.Params}}) {{if .Returns}}({{.Returns}}){{end}} {
			{{- if $flags.lock}}{{$evLoc}}.lock.RLock(); defer {{$evLoc}}.lock.RUnlock();{{end}}
			{{- if $flags.pause}}if {{$evLoc}}.paused { return };{{end}}
			{{- if $flags.wait}}{{$wg}} := {{$.SyncAliasLocal}}.WaitGroup{}; {{$wg}}.Add(len({{$evLoc}}.slots));{{end}}
			for _, {{$s}} := range {{$evLoc}}.slots {
				{{- $wrapBegin}}
				{{- if $flags.wait}}defer {{$wg}}.Done();{{end}}
				{{- if $flags.catch}}
				defer func() {
					if e := recover(); e != nil { {{$evLoc}}.catch(e) }
				}();
				{{- end}}
				{{or $hdlrParam $hdlrArg}}{{if .Name}}.{{.Name}}{{end}}({{.Args}});
				{{- $wrapEnd}}
			};
			{{- if $flags.wait}}{{$wg}}.Wait();{{end}}
			{{- if .Returns}}return{{end}}
		}
	{{end}}

	{{- $newName := prefix "New" $evTyp}}

	// {{$newName}} creates an **evon** event dispatcher {{$evTyp}}.
	func {{$newName}}({{if .Flags.queue}}qsize int,{{end}}{{if .Flags.catch}}catch func(interface{}){{end}}) *{{$evTyp}} {
		ev := &{{$evTyp}}{ {{if .Flags.queue}}qsize: qsize,{{end}}{{if .Flags.catch}}catch: catch{{end}} };
		{{- if $intf}}ev.Emit.ev = ev{{end}}
		return ev
	}

	// Sub subscribes a handler to this event dispatcher.
	func ({{$ev}} *{{$evTyp}}) Sub(handler {{$hdlrTyp}}) {{if .Flags.unsub}}func(){{end}} {
		{{- if .Flags.lock}}{{$ev}}.lock.Lock(); defer {{$ev}}.lock.Unlock();{{end}}
		{{- if .Flags.unsub}}
		idx := new(int)
		*idx = len({{$ev}}.slots);
		{{- end}}
		{{- if .Flags.queue}}q := make(chan func(), {{$ev}}.qsize){{end}}
		{{$ev}}.slots = append({{$ev}}.slots, {{if $compSlot}}{{$slotTyp}}{
			handler,{{if .Flags.unsub}} idx,{{end}}{{if .Flags.queue}} q,{{end}}
		}{{else}}handler{{end}});
		{{- if .Flags.queue}}
		go func() {
			for task := range q {
				task()
			}
		}();{{end}}
		{{- if .Flags.unsub}}
		return func() {
			{{- if .Flags.lock}}{{$ev}}.lock.Lock(); defer {{$ev}}.lock.Unlock(){{end}}
			if *idx < 0 { return }
			last := len({{$ev}}.slots)-1
			if last > *idx {
				*({{$ev}}.slots[last].index) = *idx
				{{$ev}}.slots[*idx] = {{$ev}}.slots[last]
			};
			{{- if .Flags.queue}}close(q){{end}}
			{{$ev}}.slots = {{$ev}}.slots[:last]
			*idx = -1
		}
		{{- end}}
	}

	// Count gets the current number of subscribers on this dispatcher.
	func ({{$ev}} *{{$evTyp}}) Count() int {
		{{- if .Flags.lock}}{{$ev}}.lock.RLock(); defer {{$ev}}.lock.RUnlock(){{end}}
		return len({{$ev}}.slots)
	}

	{{if .Flags.unsub}}
		// Clear unsubscribes all subscribers from this dispatcher.
		func ({{$ev}} *{{$evTyp}}) Clear() {
			{{- if .Flags.lock}}{{$ev}}.lock.Lock(); defer {{$ev}}.lock.Unlock(){{end}}
			for _, i := range {{$ev}}.slots {
				*(i.index) = -1;
				{{- if .Flags.queue}}close(i.queue){{end}}
			}
			{{$ev}}.slots = nil
		}
	{{end}}

	{{if .Flags.pause}}
		// Resume clears the paused state of this dispatcher.
		func ({{$ev}} *{{$evTyp}}) Resume() {
			{{- if .Flags.lock}}{{$ev}}.lock.RLock(); defer {{$ev}}.lock.RUnlock(){{end}}
			{{$ev}}.paused = false
		}

		// Pause stops this dispatcher from dispatching events.
		func ({{$ev}} *{{$evTyp}}) Pause() {
			{{- if .Flags.lock}}{{$ev}}.lock.RLock(); defer {{$ev}}.lock.RUnlock(){{end}}
			{{$ev}}.paused = true
		}

		// Paused checks if this dispatcher is paused.
		func ({{$ev}} *{{$evTyp}}) Paused() bool {
			{{- if .Flags.lock}}{{$ev}}.lock.RLock(); defer {{$ev}}.lock.RUnlock(){{end}}
			return {{$ev}}.paused
		}
	{{end}}
{{end}}`
